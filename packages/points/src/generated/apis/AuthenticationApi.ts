/* tslint:disable */
/* eslint-disable */
/**
 * Axis Points Server
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  JWTPair,
  RegistrationFormData,
  SigninData,
} from "../models/index";
import {
  JWTPairFromJSON,
  JWTPairToJSON,
  RegistrationFormDataFromJSON,
  RegistrationFormDataToJSON,
  SigninDataFromJSON,
  SigninDataToJSON,
} from "../models/index";

export interface AvailableUsernameGetRequest {
  username: string;
}

export interface IsRegisteredWalletAddressGetRequest {
  walletAddress: string;
}

export interface LinkPostRequest {
  signinData: SigninData;
}

export interface RefreshPostRequest {
  body: string;
}

export interface RegisterPostRequest {
  data?: RegistrationFormData;
  profileImage?: Blob;
}

export interface SignInPostRequest {
  signinData: SigninData;
}

/**
 *
 */
export class AuthenticationApi extends runtime.BaseAPI {
  /**
   * Checks if a username is available.
   */
  async availableUsernameGetRaw(
    requestParameters: AvailableUsernameGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<boolean>> {
    if (
      requestParameters.username === null ||
      requestParameters.username === undefined
    ) {
      throw new runtime.RequiredError(
        "username",
        "Required parameter requestParameters.username was null or undefined when calling availableUsernameGet.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/available/{username}`.replace(
          `{${"username"}}`,
          encodeURIComponent(String(requestParameters.username)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Checks if a username is available.
   */
  async availableUsernameGet(
    requestParameters: AvailableUsernameGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<boolean> {
    const response = await this.availableUsernameGetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Checks if a wallet address is registered.
   */
  async isRegisteredWalletAddressGetRaw(
    requestParameters: IsRegisteredWalletAddressGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<boolean>> {
    if (
      requestParameters.walletAddress === null ||
      requestParameters.walletAddress === undefined
    ) {
      throw new runtime.RequiredError(
        "walletAddress",
        "Required parameter requestParameters.walletAddress was null or undefined when calling isRegisteredWalletAddressGet.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/is_registered/{wallet_address}`.replace(
          `{${"wallet_address"}}`,
          encodeURIComponent(String(requestParameters.walletAddress)),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Checks if a wallet address is registered.
   */
  async isRegisteredWalletAddressGet(
    requestParameters: IsRegisteredWalletAddressGetRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<boolean> {
    const response = await this.isRegisteredWalletAddressGetRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Links a new wallet to a user\'s account.
   */
  async linkPostRaw(
    requestParameters: LinkPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.signinData === null ||
      requestParameters.signinData === undefined
    ) {
      throw new runtime.RequiredError(
        "signinData",
        "Required parameter requestParameters.signinData was null or undefined when calling linkPost.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.accessToken) {
      const token = this.configuration.accessToken;
      const tokenString = await token("JWTAuthorization", []);

      if (tokenString) {
        headerParameters["Authorization"] = `Bearer ${tokenString}`;
      }
    }
    const response = await this.request(
      {
        path: `/link`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SigninDataToJSON(requestParameters.signinData),
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Links a new wallet to a user\'s account.
   */
  async linkPost(
    requestParameters: LinkPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.linkPostRaw(requestParameters, initOverrides);
  }

  /**
   * Get a nonce for a sign in request.
   */
  async nonceGetRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const response = await this.request(
      {
        path: `/nonce`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   * Get a nonce for a sign in request.
   */
  async nonceGet(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.nonceGetRaw(initOverrides);
    return await response.value();
  }

  /**
   * Checks a provided refresh token, returns a new access token and refresh token.
   */
  async refreshPostRaw(
    requestParameters: RefreshPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<JWTPair>> {
    if (
      requestParameters.body === null ||
      requestParameters.body === undefined
    ) {
      throw new runtime.RequiredError(
        "body",
        "Required parameter requestParameters.body was null or undefined when calling refreshPost.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/refresh`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: requestParameters.body as any,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      JWTPairFromJSON(jsonValue),
    );
  }

  /**
   * Checks a provided refresh token, returns a new access token and refresh token.
   */
  async refreshPost(
    requestParameters: RefreshPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<JWTPair> {
    const response = await this.refreshPostRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Registers a new user. The wallet address being registered must not be registered already.
   */
  async registerPostRaw(
    requestParameters: RegisterPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<JWTPair>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    const consumes: runtime.Consume[] = [
      { contentType: "multipart/form-data" },
    ];
    // @ts-ignore: canConsumeForm may be unused
    const canConsumeForm = runtime.canConsumeForm(consumes);

    let formParams: { append(param: string, value: any): any };
    let useForm = false;
    // use FormData to transmit files using content-type "multipart/form-data"
    useForm = canConsumeForm;
    if (useForm) {
      formParams = new FormData();
    } else {
      formParams = new URLSearchParams();
    }

    if (requestParameters.data !== undefined) {
      formParams.append(
        "data",
        new Blob(
          [JSON.stringify(RegistrationFormDataToJSON(requestParameters.data))],
          { type: "application/json" },
        ),
      );
    }

    if (requestParameters.profileImage !== undefined) {
      formParams.append("profile_image", requestParameters.profileImage as any);
    }

    const response = await this.request(
      {
        path: `/register`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: formParams,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      JWTPairFromJSON(JSON.parse(jsonValue)),
    );
  }

  /**
   * Registers a new user. The wallet address being registered must not be registered already.
   */
  async registerPost(
    requestParameters: RegisterPostRequest = {},
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<JWTPair> {
    const response = await this.registerPostRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   * Signs the user in, creating and returning a JWT.
   */
  async signInPostRaw(
    requestParameters: SignInPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<JWTPair>> {
    if (
      requestParameters.signinData === null ||
      requestParameters.signinData === undefined
    ) {
      throw new runtime.RequiredError(
        "signinData",
        "Required parameter requestParameters.signinData was null or undefined when calling signInPost.",
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    const response = await this.request(
      {
        path: `/sign-in`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SigninDataToJSON(requestParameters.signinData),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      JWTPairFromJSON(JSON.parse(jsonValue)),
    );
  }

  /**
   * Signs the user in, creating and returning a JWT.
   */
  async signInPost(
    requestParameters: SignInPostRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<JWTPair> {
    const response = await this.signInPostRaw(requestParameters, initOverrides);
    return await response.value();
  }
}
